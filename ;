extends Node3D

class_name RayCastHitDetector

@export_group("Debug Settings")
## Toggles debug drawing of RayCastHitPoints each frame.
@export var debug_draw := false
## How long each line segment should exist for after generation.
@export var segment_lifetime := 1.0

@export_group("Detection Settings")

var _detecting := false

var _hit_entities := []
var hit_point_data: Dictionary
# Positions of each hit point on the last frame
var _exclusion_RIDs: Array[RID]

func draw_debug_line() -> void:
	# Precheck to remove any expired segments
	pass
	# Some mesh logic here..

func get_exclusions() -> Array[RID]:
	return _exclusion_RIDs

func add_exclusion(exclude: CollisionObject3D) -> void:
	if _exclusion_RIDs.find(exclude.get_rid()) == -1:
		_exclusion_RIDs.append(exclude.get_rid())

func remove_exclusion(exclude: CollisionObject3D) -> void:
	_exclusion_RIDs.erase(exclude.get_rid())

func get_hit_point_data(point_name: String) -> RayCastHitPoint:
	return hit_point_data[point_name] if hit_point_data.has(point_name) else null

func add_point(point: RayCastHitPoint) -> void:
	assert(!hit_point_data.has(point.name), "Attempted to add two hit points with the same name!")
	var default_data: Dictionary = {
		"points": {},
		"node": null
	}	
	hit_point_data[point.name] = default_data
	hit_point_data[point.name].points[point.global_position] = Time.get_ticks_msec()
	hit_point_data[point.name].node = point

func begin() -> void:
	_detecting = true

func end() -> void:
	_detecting = false

func remove_point(point: RayCastHitPoint) -> void:
	assert(hit_point_data.has(point.name), "Attempted to remove point that doesn't exist!")
	hit_point_data.erase(point.name)

func _ready():
	print_debug(get_children())
	for child in get_children():
		if child is RayCastHitPoint:
			add_point(child)
			if debug_draw:
				child.mesh = MeshInstance3D.new()
				child.mesh.top_level = true
				child.add_child(child.mesh)
				child.mesh.position = Vector3.ZERO
				child.mesh.global_position = child.global_position
				child.mesh.mesh = ImmediateMesh.new()

func _draw_debug_mesh(point: RayCastHitPoint) -> void:
	assert(hit_point_data.has(point.name), "Point does not exist in hit point data.")

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _physics_process(delta: float) -> void:
	if not _detecting:
		return

	var keys = hit_point_data.keys()
	for key in keys:
		var data: Dictionary = hit_point_data[key]
		var points: Dictionary = data.points
		var node: RayCastHitPoint = data.node as RayCastHitPoint

		var space_state := get_world_3d().direct_space_state

		var origin = data.points.keys().back()
		var end = node.global_position
		data.points[end] = Time.get_ticks_msec()

		if debug_draw:
			var imesh: ImmediateMesh = node.mesh.mesh
			imesh.clear_surfaces()

			imesh.surface_begin(Mesh.PRIMITIVE_LINES)

			for point in data.points.keys():
				if Time.get_ticks_msec() - data.points[point] >= segment_lifetime * 1000:
					data.points.erase(point) 

			imesh.surface_add_vertex(data.points.keys().front())
			for i in range(1, points.keys().size() - 1):
				var point: Vector3 = data.points.keys()[i]
				imesh.surface_add_vertex(point)
				imesh.surface_add_vertex(point)
			imesh.surface_add_vertex(data.points.keys().back())

			imesh.surface_end()

		var query = PhysicsRayQueryParameters3D.create(origin, end)
		query.hit_from_inside = true
		query.exclude = _exclusion_RIDs
		query.collide_with_areas = true
		query.collide_with_bodies = true
		
		var result = space_state.intersect_ray(query)		
		if result:
			# update to handle multiple intersections later
			print_debug(result)
